"""
Flexible Control Framework (FCF) Numerical Analysis and Simulation
-----------------------------------------------------------------
This script reproduces all analyses and figures reported in:
"The Flexible Control Framework: A Unified Theory of Stability through Flexibility in Neural Control"

Author: [Your Name]
Affiliation: [Your Institution]
License: MIT
Date: 2025-12-12

Dependencies:
    numpy >= 1.26
    matplotlib >= 3.8
"""

import numpy as np
import matplotlib.pyplot as plt

# -------------------------
# 1. Reproducibility setup
# -------------------------
np.random.seed(42)

# -------------------------
# 2. Simulation parameters
# -------------------------
epochs = 200
cac = np.linspace(0.05, 0.5, epochs)  # Compensatory Adjustment Capacity (learning proxy)
sigma = 0.3  # Gaussian noise (environmental perturbation)

# -------------------------
# 3. Initialize state & output
# -------------------------
x = np.zeros((epochs, 3))  # state vector [x1, x2, x3]
y = np.zeros((epochs, 2))  # task output [y1, y2]
error = np.zeros(epochs)   # task error (‖y‖)

# -------------------------
# 4. Main simulation loop (Flexible Control Framework)
# -------------------------
for t in range(1, epochs):
    # Task feedback control (goal-directed correction)
    control = -0.1 * (x[t-1, 0] + x[t-1, 1])

    # Stochastic perturbation (environmental noise)
    noise = np.random.normal(0, sigma, 3)

    # Null-space compensation scaled by CAC (flexibility term)
    compensation = cac[t] * np.array([1, -1, 0])

    # State update
    x[t] = x[t-1] + np.array([control, control, 0]) + noise + compensation

    # Task output mapping
    y[t, 0] = x[t, 0] + x[t, 1]
    y[t, 1] = x[t, 2]

    # Compute task error magnitude
    error[t] = np.linalg.norm(y[t])

# -------------------------
# 5. Quantitative analysis
# -------------------------
mean_error = np.mean(error[50:])  # exclude transient phase
std_error = np.std(error[50:])
corr = np.corrcoef(cac, error)[0, 1]

print("=== Flexible Control Framework Simulation Summary ===")
print(f"Mean steady-state error: {mean_error:.3f}")
print(f"Error variability (SD): {std_error:.3f}")
print(f"CAC–Error correlation: {corr:.3f}")
print("------------------------------------------------------")

# -------------------------
# 6. Figure 1 – Learning dynamics
# -------------------------
plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.plot(error, linewidth=2)
plt.title("Task Error over Learning")
plt.xlabel("Epoch")
plt.ylabel("Task Error (‖y‖)")
plt.grid(True)

plt.subplot(1, 2, 2)
plt.plot(cac, linewidth=2)
plt.title("Compensatory Adjustment Capacity (CAC)")
plt.xlabel("Epoch")
plt.ylabel("CAC value")
plt.grid(True)

plt.tight_layout()
plt.savefig("Figure1_FCF_dynamics.png", dpi=300)
plt.show()

# -------------------------
# 7. Figure 2 – CAC vs Mean Task Error
# -------------------------
window = 10
mean_cac = [np.mean(cac[i:i+window]) for i in range(0, epochs-window, window)]
mean_error_window = [np.mean(error[i:i+window]) for i in range(0, epochs-window, window)]

corr2 = np.corrcoef(mean_cac, mean_error_window)[0, 1]

plt.figure(figsize=(6, 5))
plt.scatter(mean_cac, mean_error_window, s=40)
plt.plot(np.poly1d(np.polyfit(mean_cac, mean_error_window, 1))(mean_cac),
         color='black', linestyle='--')
plt.title(f"Figure 2. CAC vs Task Error (r = {corr2:.2f})")
plt.xlabel("Compensatory Adjustment Capacity (CAC)")
plt.ylabel("Mean Task Error (‖y‖)")
plt.grid(True)
plt.tight_layout()
plt.savefig("Figure2_CAC_vs_Error.png", dpi=300)
plt.show()

print("Figures saved as 'Figure1_FCF_dynamics.png' and 'Figure2_CAC_vs_Error.png'")
print("Simulation complete. Reproducible with identical output using seed=42.")
